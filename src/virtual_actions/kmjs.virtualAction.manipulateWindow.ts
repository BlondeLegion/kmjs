//FILE: src/virtual_actions/kmjs.virtualAction.manipulateWindow.ts

import chalk from "chalk";
import { formatXmlAction, escapeForXml, kmKeyOrder } from "../utils/utils.xml";
import {
  generateActionUIDXml,
  renderStopOnFailureXml,
  renderNotifyOnFailureXml,
} from "../utils/template.xml.generic";
import {
  generateApplicationXml,
  getMoveAndResizeDefaults,
} from "../utils/template.xml.application";
import type { VirtualAction } from "./types";
import type {
  SpecificAppOptions,
  ApplicationTarget,
  WindowManipulation,
  MoveAndResizePreset,
  WindowTarget,
} from "./types/types.ui";
import type { StopOnFailure, NotifyOnFailure } from "./types/types.system";

/**
 * Options for configuring a ManipulateWindow action.
 */
export interface ManipulateWindowOptions {
  /**
   * The type of window manipulation to perform.
   * @default "Center"
   */
  manipulation?: WindowManipulation;

  /**
   * For ScaleBy, ResizeBy, ResizeTo, MoveBy, MoveTo operations.
   * Should be a 2-element array [horizontal, vertical] or [width, height].
   */
  values?: [string, string];

  /**
   * For MoveAndResize operations, the preset configuration to use.
   * @default "Custom"
   */
  moveAndResizePreset?: MoveAndResizePreset;

  /**
   * For MoveAndResize Custom operations: 4-element array [horizontal, vertical, width, height]
   * For CenterAt operations: 3-element array [x, y, z]
   */
  customValues?: [string, string, string] | [string, string, string, string];

  /**
   * Which window(s) to target.
   * @default "FrontWindow"
   */
  windowTarget?: WindowTarget;

  /**
   * For window targeting that requires a string parameter.
   */
  windowIdentifier?: string;

  /**
   * For window targeting that requires an integer parameter.
   */
  windowIndex?: number;

  /**
   * Application targeting (not used for KMWindowID or KMLastWindow).
   * @default "Front"
   */
  applicationTarget?: ApplicationTarget;

  /**
   * If targeting a specific application.
   */
  specificApplication?: SpecificAppOptions;

  /**
   * If false, failure does not abort macro (default true).
   */
  stopOnFailure?: StopOnFailure;

  /**
   * If false, do not notify on failure (default true).
   */
  notifyOnFailure?: NotifyOnFailure;
}

/**
 * Constructs a VirtualAction that manipulates windows in Keyboard Maestro.
 * This function generates the correct XML fragment for the Manipulate Window action,
 * supporting all permutations of window manipulation, targeting, and application options.
 *
 * The function is highly modular: each XML sub-block is generated by a dedicated helper,
 * making the final XML structure easy to read and maintain.
 *
 * @param opts - ManipulateWindowOptions specifying the manipulation type, window/app targeting, and parameters.
 * @returns A VirtualAction object with a toXml() method for rendering the KM XML.
 */
export function createVirtualManipulateWindow(
  opts: ManipulateWindowOptions = {},
): VirtualAction {
  const {
    manipulation = "CenterWindow",
    values = ["0", "0"],
    moveAndResizePreset = "Custom",
    customValues,
    windowTarget = "FrontWindow",
    windowIdentifier = "",
    windowIndex = 1,
    applicationTarget = "Front",
    specificApplication = {},
    stopOnFailure,
    notifyOnFailure,
  } = opts;

  // Use the manipulation value directly (now matches KM action string)
  const actionName = manipulation;

  // --- Compute all expression values up front ---
  let horizontal = values[0],
    vertical = values[1],
    width = values[0],
    height = values[1];
  if (
    [
      "ResizeBy",
      "ResizeTo",
      "ResizeWindowByPercent",
      "ScaleBy",
      "MoveBy",
      "MoveTo",
      "MoveWindowBy",
      "MoveWindowTo",
      "MoveAndResize",
      "Center",
      "CenterAt",
      "Close",
      "Zoom",
      "Minimize",
      "ReallyMinimizeWindow",
      "Unminimize",
      "ToggleMinimize",
      "BringToFront",
      "SelectWindow",
    ].includes(actionName)
  ) {
    if (manipulation === "MoveAndResize") {
      let expressions: [string, string, string, string];

      if (customValues && customValues.length === 4) {
        // 4-element array: full control over horizontal, vertical, width, height
        expressions = [
          customValues[0], // horizontal
          customValues[1], // vertical
          customValues[2], // width
          customValues[3], // height
        ];
      } else {
        // Use preset defaults
        expressions = getMoveAndResizeDefaults(moveAndResizePreset);
      }

      horizontal = expressions[0];
      vertical = expressions[1];
      width = expressions[2];
      height = expressions[3];
    } else if (
      manipulation === "CenterWindowAt" &&
      customValues &&
      customValues.length >= 3
    ) {
      // CenterAt uses 3-element array: [x, y, z] where z might be radius or size
      horizontal = customValues[0]; // x position
      vertical = customValues[1]; // y position
      width = customValues[2]; // size or radius
      height = customValues[2]; // same as width for center operations
    } else if (customValues && customValues.length >= 2) {
      horizontal = customValues[0];
      vertical = customValues[1];
    }
  }

  // --- Build the XML lines in canonical order ---
  /**
   * The canonical order for ManipulateWindow is:
   * Action, ActionUID, HeightExpression, HorizontalExpression, MacroActionType, TargetApplication, Targeting, TargetingType, VerticalExpression, WidthExpression, WindowIndexExpression, WindowName, WindowID (if present)
   * (WindowID only for KMWindowID)
   */
  const getWindowIndexString = () => {
    if (windowTarget === "FrontWindow") return "2";
    if (windowTarget === "WindowIndex") return String(windowIndex);
    return "";
  };

  // TargetApplication block: present for all except KMWindowID/KMLastWindow
  let targetAppXml: string[] = [];
  if (windowTarget !== "KMWindowID" && windowTarget !== "KMLastWindow") {
    if (applicationTarget === "Specific") {
      targetAppXml = [
        "\t\t<key>TargetApplication</key>",
        ...generateApplicationXml(applicationTarget, specificApplication).map(
          (line) => "\t\t" + line,
        ),
      ];
    } else {
      targetAppXml = ["\t\t<key>TargetApplication</key>", "\t\t<dict/>"];
    }
  }

  // Build XML as an array of lines, not a joined string
  const xmlLines: string[] = [
    "\t<dict>",
    // Action
    "\t\t<key>Action</key>",
    `\t\t<string>${actionName}</string>`,
    // ActionUID (use generateActionUIDXml for block)
    ...generateActionUIDXml().map((l) => "\t\t" + l.trim()),
    // HeightExpression
    "\t\t<key>HeightExpression</key>",
    `\t\t<string>${escapeForXml(height)}</string>`,
    // HorizontalExpression
    "\t\t<key>HorizontalExpression</key>",
    `\t\t<string>${escapeForXml(horizontal)}</string>`,
    // MacroActionType
    "\t\t<key>MacroActionType</key>",
    "\t\t<string>ManipulateWindow</string>",
    // Add failure handling options (right after MacroActionType, matching ground truth)
    ...(notifyOnFailure !== undefined
      ? renderNotifyOnFailureXml(notifyOnFailure)
      : []),
    ...(stopOnFailure !== undefined
      ? renderStopOnFailureXml(stopOnFailure)
      : []),
    // TargetApplication (present for all except KMWindowID/KMLastWindow)
    ...targetAppXml,
    // Targeting
    "\t\t<key>Targeting</key>",
    `\t\t<string>${windowTarget}</string>`,
    // TargetingType (only for non-KMWindowID/KMLastWindow)
    ...(windowTarget !== "KMWindowID" && windowTarget !== "KMLastWindow"
      ? [
          "\t\t<key>TargetingType</key>",
          `\t\t<string>${applicationTarget}</string>`,
        ]
      : []),
    // VerticalExpression
    "\t\t<key>VerticalExpression</key>",
    `\t\t<string>${escapeForXml(vertical)}</string>`,
    // WidthExpression
    "\t\t<key>WidthExpression</key>",
    `\t\t<string>${escapeForXml(width)}</string>`,
    // --- Window-specific keys in correct order ---
    ...(windowTarget === "KMWindowID"
      ? [
          "\t\t<key>WindowID</key>",
          `\t\t<string>${escapeForXml(windowIdentifier)}</string>`,
          "\t\t<key>WindowIndexExpression</key>",
          `\t\t<string></string>`,
          "\t\t<key>WindowName</key>",
          `\t\t<string></string>`,
        ]
      : windowTarget === "WindowIndex"
        ? [
            "\t\t<key>WindowIndexExpression</key>",
            `\t\t<string>${windowIndex}</string>`,
            "\t\t<key>WindowName</key>",
            `\t\t<string></string>`,
          ]
        : windowTarget === "NamedWindow" ||
            windowTarget === "WindowNameContaining" ||
            windowTarget === "WindowNameMatching"
          ? [
              "\t\t<key>WindowIndexExpression</key>",
              `\t\t<string></string>`,
              "\t\t<key>WindowName</key>",
              `\t\t<string>${escapeForXml(windowIdentifier)}</string>`,
            ]
          : [
              // Default: FrontWindow, KMLastWindow, etc.
              "\t\t<key>WindowIndexExpression</key>",
              `\t\t<string>2</string>`,
              "\t\t<key>WindowName</key>",
              `\t\t<string></string>`,
            ]),
    "\t</dict>",
  ];

  /**
   * Renders the fully-formed Keyboard Maestro XML for this ManipulateWindow action.
   * @returns {string} The formatted XML string.
   */
  return { toXml: () => formatXmlAction(xmlLines.join("\n")) };
}
